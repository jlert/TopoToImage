#!/usr/bin/env python3
"""
Key File Generator for DEM Visualizer
Generates PDF legend files compatible with Adobe Illustrator
"""

import os
import math
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from PIL import Image, ImageDraw
import numpy as np

try:
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.units import inch
    from reportlab.lib.colors import Color
    from reportlab.lib.utils import ImageReader
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image as RLImage
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.enums import TA_LEFT, TA_CENTER
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False
    # Provide fallback values when reportlab is not available
    letter = (612, 792)  # Standard letter size in points
    inch = 72  # 72 points per inch
    print("‚ö†Ô∏è reportlab not available - Key file generation disabled")

class KeyFileGenerator:
    """
    Generates PDF Key files for DEM terrain visualizations
    Compatible with Adobe Illustrator with layered elements
    """
    
    def __init__(self, gradient_manager, terrain_renderer):
        self.gradient_manager = gradient_manager
        self.terrain_renderer = terrain_renderer
        
        # PDF Layout constants (in points - 72 points per inch)
        self.page_width, self.page_height = letter
        self.margin = 36  # 0.5 inch margins
        self.gradient_bar_width = 24  # Reduced from 48 to 24
        self.gradient_bar_height = 360
        self.font_size_title = 20  # Reduced from 24 to 20
        self.font_size_normal = 12
        self.font_size_small = 10
        
        # Earth radius for distance calculations (km)
        self.earth_radius_km = 6371.0072
        
    def generate_key_file(self, export_data: Dict, output_path: str) -> bool:
        """
        Generate a Key file PDF for the exported terrain visualization
        
        Args:
            export_data: Dictionary containing export metadata
            output_path: Path where the Key file should be saved
            
        Returns:
            bool: True if successful, False otherwise
        """
        if not REPORTLAB_AVAILABLE:
            print("‚ùå Cannot generate Key file - reportlab not installed")
            return False
            
        try:
            print(f"üìÑ Creating PDF canvas: {output_path}")
            # Create PDF canvas
            c = canvas.Canvas(output_path, pagesize=letter)
            
            # Set up layers for Adobe Illustrator compatibility
            print("üé® Setting up PDF layers for Adobe Illustrator compatibility")
            self._setup_pdf_layers(c)
            
            # Generate gradient bar image
            print("üåà Generating gradient bar image")
            gradient_bar_image = self._create_gradient_bar_image(export_data)
            
            # Draw all elements
            print("üìù Drawing header section")
            self._draw_header(c, export_data)
            print("üìä Drawing unified info panel")
            self._draw_info_panel(c, export_data)
            print("üìà Drawing gradient legend section")
            self._draw_gradient_legend(c, export_data, gradient_bar_image)
            print("üé® Drawing special colors section")
            self._draw_special_colors(c, export_data)
            
            # Save the PDF
            print("üíæ Saving PDF file")
            c.save()
            print(f"‚úÖ Key file generated: {output_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error generating Key file: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _setup_pdf_layers(self, c: "canvas.Canvas"):
        """Set up PDF layers for Adobe Illustrator compatibility"""
        # ReportLab doesn't directly support layers, but we can use groups
        # which Illustrator can interpret as separate objects
        pass
    
    def _draw_header(self, c: "canvas.Canvas", export_data: Dict):
        """Draw the header section with title and basic info"""
        # Start from top of page
        y = self.page_height - self.margin - 30
        
        # Title
        c.setFont("Helvetica-Bold", self.font_size_title)
        filename = export_data.get('filename', 'Unknown')
        title = f"Key for {filename}"
        c.drawString(self.margin, y, title)
        
        # Subtitle line - import version info
        from version import get_app_name_with_version
        y -= 40
        c.setFont("Helvetica", self.font_size_normal)
        c.drawString(self.margin, y, f"Generated by {get_app_name_with_version()}")
    
    def _draw_info_panel(self, c: "canvas.Canvas", export_data: Dict):
        """Draw unified information panel with consistent spacing at 250pt from left"""
        x = 250  # Consistent left position for all info
        y = self.page_height - self.margin - 120 - 18  # Start position moved down one line
        line_height = 18
        
        c.setFont("Helvetica", self.font_size_normal)
        
        # 1. EXPORT METADATA SECTION
        db_name = export_data.get('database_name', 'Unknown Database')
        c.drawString(x, y, f"Database name: {db_name}")
        y -= line_height
        
        gradient_name = export_data.get('gradient_name', 'Unknown Gradient')
        c.drawString(x, y, f"Gradient name: {gradient_name}")
        y -= line_height
        
        gradient_type = self._get_gradient_type_name(export_data.get('gradient_type', 'gradient'))
        c.drawString(x, y, f"Gradient type: {gradient_type}")
        y -= line_height
        
        export_scale = export_data.get('export_scale', 100)
        c.drawString(x, y, f"Export scale: {export_scale}%")
        y -= line_height
        
        pixel_width = export_data.get('pixel_width', 0)
        pixel_height = export_data.get('pixel_height', 0)
        c.drawString(x, y, f"Pixel width: {pixel_width}")
        y -= line_height
        c.drawString(x, y, f"Pixel height: {pixel_height}")
        y -= line_height
        
        # Blank line separator
        y -= line_height
        
        # 2. GEOGRAPHIC BOUNDS SECTION
        west = export_data.get('west', 0)
        north = export_data.get('north', 0)
        east = export_data.get('east', 0)
        south = export_data.get('south', 0)
        
        c.drawString(x, y, f"West side: {self._format_coordinate(west, False)} ({west:.6f})")
        y -= line_height
        c.drawString(x, y, f"North side: {self._format_coordinate(north, True)} ({north:.6f})")
        y -= line_height
        c.drawString(x, y, f"East side: {self._format_coordinate(east, False)} ({east:.6f})")
        y -= line_height
        c.drawString(x, y, f"South side: {self._format_coordinate(south, True)} ({south:.6f})")
        y -= line_height
        
        # Blank line separator
        y -= line_height
        
        # 3. DISTANCE CALCULATIONS SECTION
        top_width_km, top_width_mi = self._calculate_width_distance(west, east, north)
        middle_width_km, middle_width_mi = self._calculate_width_distance(west, east, (north + south) / 2)
        bottom_width_km, bottom_width_mi = self._calculate_width_distance(west, east, south)
        height_km, height_mi = self._calculate_height_distance(north, south)
        
        c.drawString(x, y, f"Map width is {top_width_mi:.1f} mi. ({top_width_km:.1f} km) at the top")
        y -= line_height
        c.drawString(x, y, f"Map width is {middle_width_mi:.1f} mi. ({middle_width_km:.1f} km) in the middle")
        y -= line_height
        c.drawString(x, y, f"Map width is {bottom_width_mi:.1f} mi. ({bottom_width_km:.1f} km) at the bottom")
        y -= line_height
        c.drawString(x, y, f"Map height is {height_mi:.1f} mi. ({height_km:.1f} km)")
        y -= line_height
        
        # 4. SHADING PARAMETERS SECTION (if applicable)
        gradient_name = export_data.get('gradient_name', '')
        if gradient_name:
            gradient = self.gradient_manager.get_gradient(gradient_name)
            if gradient and gradient.gradient_type in ['shaded_relief', 'shading_and_gradient', 'shading_and_posterized']:
                # Blank line separator
                y -= line_height
                
                c.drawString(x, y, f"Light direction: {gradient.light_direction}¬∞")
                y -= line_height
                c.drawString(x, y, f"Shading intensity: {gradient.shading_intensity}%")
                y -= line_height
                c.drawString(x, y, f"Blending mode: {gradient.blending_mode}")
                y -= line_height
                c.drawString(x, y, f"Blending strength: {gradient.blending_strength}%")
                y -= line_height
                
                if gradient.cast_shadows:
                    c.drawString(x, y, f"Shadow drop distance: {gradient.shadow_drop_distance}")
                    y -= line_height
                    c.drawString(x, y, f"Shadow soft edge: {gradient.shadow_soft_edge}")
                    y -= line_height
    
    def _draw_gradient_legend(self, c: "canvas.Canvas", export_data: Dict, gradient_bar_image: Optional[Image.Image]):
        """Draw the gradient bar and elevation labels"""
        # Position gradient bar
        bar_x = self.margin
        bar_y = self.page_height - self.margin - 500
        
        # Draw gradient bar if available
        if gradient_bar_image:
            # Save gradient bar as temporary image
            temp_path = "/tmp/gradient_bar.png"
            gradient_bar_image.save(temp_path)
            
            # Draw the gradient bar
            c.drawImage(temp_path, bar_x, bar_y, 
                       width=self.gradient_bar_width, 
                       height=self.gradient_bar_height)
            
            # Clean up temp file
            try:
                os.remove(temp_path)
            except:
                pass
        
        # No outline drawn for gradient bar
        
        # Draw top and bottom elevation labels
        self._draw_gradient_elevation_labels(c, export_data, bar_x, bar_y)
        
        # Draw elevation labels for color points
        self._draw_elevation_labels(c, export_data, bar_x, bar_y)
    
    def _draw_gradient_elevation_labels(self, c: "canvas.Canvas", export_data: Dict, bar_x: float, bar_y: float):
        """Draw top and bottom elevation labels for the gradient bar"""
        gradient_name = export_data.get('gradient_name', '')
        if not gradient_name:
            return
            
        gradient = self.gradient_manager.get_gradient(gradient_name)
        if not gradient:
            return
        
        # Get elevation range from export_data (main window) instead of gradient
        min_elev = export_data.get('min_elevation', gradient.min_elevation)
        max_elev = export_data.get('max_elevation', gradient.max_elevation)
        units = "m"  # All elevations use meters only
        
        c.setFont("Helvetica", self.font_size_small)
        
        # Top elevation label (above gradient bar, flush left with bar)
        top_y = bar_y + self.gradient_bar_height + 12  # 12 points above gradient bar
        top_elevation_text = f"{max_elev:.0f} {units}"
        c.drawString(bar_x, top_y, top_elevation_text)
        
        # Bottom elevation label (below gradient bar, flush left with bar)
        bottom_y = bar_y - 18  # 18 points below gradient bar
        bottom_elevation_text = f"{min_elev:.0f} {units}"
        c.drawString(bar_x, bottom_y, bottom_elevation_text)
    
    def _draw_elevation_labels(self, c: "canvas.Canvas", export_data: Dict, bar_x: float, bar_y: float):
        """Draw elevation labels with connecting lines - using correct Y position calculation"""
        gradient_name = export_data.get('gradient_name', '')
        if not gradient_name:
            return
            
        gradient = self.gradient_manager.get_gradient(gradient_name)
        if not gradient:
            return
        
        # Get elevation range from export_data (main window) instead of gradient
        min_elev = export_data.get('min_elevation', gradient.min_elevation)
        max_elev = export_data.get('max_elevation', gradient.max_elevation)
        elev_range = max_elev - min_elev
        
        # Position for labels
        label_x = bar_x + self.gradient_bar_width + 20
        
        c.setFont("Helvetica", self.font_size_small)
        
        # Draw labels for each color stop using CORRECT formulas
        for i, color_stop in enumerate(gradient.color_stops):
            # Calculate elevation from position - CORRECTED FORMULA
            # Position 0.0 = top = max_elevation, Position 1.0 = bottom = min_elevation
            # elevation = min_elev + (max_elev - min_elev) * (1 - position)
            elevation = min_elev + (elev_range * (1 - color_stop.position))
            elevation = round(elevation)
            
            # Calculate Y position using USER'S EXACT FORMULA for color points and labels
            # User's formula: Y = (Gradient bar height * position) + (Bottom of gradient bar - Gradient bar height)
            # Bottom of gradient bar in user's coordinate system = 536
            # So: Y = (Gradient bar height * position) + (536 - Gradient bar height)
            # This gives: First point Y = (360 √ó 0.05) + (536 - 360) = 18 + 176 = 194
            bottom_of_gradient_bar = 536  # User's expected coordinate system
            point_y = ((self.gradient_bar_height * color_stop.position) + (bottom_of_gradient_bar - self.gradient_bar_height)) * -1 + 792
            
            # Draw elevation label
            units = "m" if gradient.units == "meters" else "ft"
            elevation_text = f"{elevation:.0f} {units}"
            rgb_text = f"RGB({color_stop.red}, {color_stop.green}, {color_stop.blue})"
            
            # Draw elevation and RGB text (at same Y position as color point)
            c.drawString(label_x + 16, point_y + 6, elevation_text)
            c.drawString(label_x + 16, point_y - 6, rgb_text)
            
            # Draw connecting line from gradient bar to color point
            c.setLineWidth(0.25)  # Thin line
            c.line(bar_x + self.gradient_bar_width, point_y, label_x - 5, point_y)
            
            # Draw color chip as circle (at same Y position as labels)
            color_chip_radius = 6
            chip_x = label_x + 1  # Position at start of line
            chip_y = point_y  # Same Y position for labels, lines, and color points
            
            # Set color and draw filled circle
            r = color_stop.red / 255.0
            g = color_stop.green / 255.0
            b = color_stop.blue / 255.0
            c.setFillColor(Color(r, g, b))
            c.circle(chip_x, chip_y, color_chip_radius, fill=1)
            
            # Draw thin outline around circle
            c.setStrokeColor(Color(0, 0, 0))  # Black outline
            c.setLineWidth(0.25)  # Thin outline
            c.circle(chip_x, chip_y, color_chip_radius, fill=0, stroke=1)
            
            # Reset color to black for text
            c.setFillColor(Color(0, 0, 0))
    
    def _draw_special_colors(self, c: "canvas.Canvas", export_data: Dict):
        """Draw special color indicators with proper positioning"""
        gradient_name = export_data.get('gradient_name', '')
        if not gradient_name:
            return
            
        gradient = self.gradient_manager.get_gradient(gradient_name)
        if not gradient:
            return
        
        # Get gradient bar position for reference
        bar_x = self.margin
        bar_y = self.page_height - self.margin - 500
        
        chip_radius = 6  # Use circles like gradient points
        c.setFont("Helvetica", self.font_size_small)
        
        # 1. Above gradient color - ABOVE the gradient bar, centered over it
        if (gradient.gradient_type in ['posterized', 'shading_and_posterized'] and 
            hasattr(gradient, 'below_gradient_color') and gradient.below_gradient_color):
            # Use the below_gradient_color (which is the "above posterized" color)
            color = gradient.below_gradient_color
            
            # Position above gradient bar, centered (moved up to make room for top elevation label)
            chip_x = bar_x + self.gradient_bar_width / 2
            chip_y = bar_y + self.gradient_bar_height + 45  # Moved up 15 points
            
            r = color['red'] / 255.0
            g = color['green'] / 255.0
            b = color['blue'] / 255.0
            c.setFillColor(Color(r, g, b))
            c.circle(chip_x, chip_y, chip_radius, fill=1)
            
            # Add thin outline
            c.setStrokeColor(Color(0, 0, 0))
            c.setLineWidth(0.25)
            c.circle(chip_x, chip_y, chip_radius, fill=0, stroke=1)
            
            # Add RGB values and label
            c.setFillColor(Color(0, 0, 0))
            rgb_text = f"RGB({color['red']}, {color['green']}, {color['blue']})"
            c.drawString(chip_x + chip_radius + 15, chip_y + 5, "Color for elevations above gradient (posterized only)")
            c.drawString(chip_x + chip_radius + 15, chip_y - 5, rgb_text)
        
        # 2. & 3. Below gradient bar - No-data and Shadow colors (moved down to make room for bottom elevation label)
        below_bar_y = bar_y - 55  # Moved down 15 points
        
        # No-data color (Oceans)
        if gradient.no_data_color:
            color = gradient.no_data_color
            chip_x = bar_x + 12  # Move 8 points left to align under gradient bar
            
            r = color['red'] / 255.0
            g = color['green'] / 255.0
            b = color['blue'] / 255.0
            c.setFillColor(Color(r, g, b))
            c.circle(chip_x, below_bar_y, chip_radius, fill=1)
            
            # Add thin outline
            c.setStrokeColor(Color(0, 0, 0))
            c.setLineWidth(0.25)
            c.circle(chip_x, below_bar_y, chip_radius, fill=0, stroke=1)
            
            # Add RGB values and label
            c.setFillColor(Color(0, 0, 0))
            rgb_text = f"RGB({color['red']}, {color['green']}, {color['blue']})"
            c.drawString(chip_x + chip_radius + 15, below_bar_y + 5, "Color for no-data areas (Oceans)")
            c.drawString(chip_x + chip_radius + 15, below_bar_y - 5, rgb_text)
        
        # Shadow color
        if gradient.shadow_color:
            color = gradient.shadow_color
            chip_x = bar_x + 12  # Move 8 points left to align under gradient bar
            shadow_y = below_bar_y - 30
            
            r = color['red'] / 255.0
            g = color['green'] / 255.0
            b = color['blue'] / 255.0
            c.setFillColor(Color(r, g, b))
            c.circle(chip_x, shadow_y, chip_radius, fill=1)
            
            # Add thin outline
            c.setStrokeColor(Color(0, 0, 0))
            c.setLineWidth(0.25)
            c.circle(chip_x, shadow_y, chip_radius, fill=0, stroke=1)
            
            # Add RGB values and label
            c.setFillColor(Color(0, 0, 0))
            rgb_text = f"RGB({color['red']}, {color['green']}, {color['blue']})"
            c.drawString(chip_x + chip_radius + 15, shadow_y + 5, "Shadow color")
            c.drawString(chip_x + chip_radius + 15, shadow_y - 5, rgb_text)
    
    def _create_gradient_bar_image(self, export_data: Dict) -> Optional[Image.Image]:
        """Create PIL Image of the gradient bar"""
        try:
            gradient_name = export_data.get('gradient_name', '')
            if not gradient_name:
                return None
                
            gradient = self.gradient_manager.get_gradient(gradient_name)
            if not gradient:
                return None
            
            # Create image
            width = self.gradient_bar_width
            height = self.gradient_bar_height
            image = Image.new('RGB', (width, height), 'white')
            
            # For posterized gradients, create discrete bands
            if gradient.gradient_type in ['posterized', 'shading_and_posterized']:
                self._create_posterized_gradient_bar(image, gradient)
            else:
                self._create_smooth_gradient_bar(image, gradient)
            
            return image
            
        except Exception as e:
            print(f"‚ùå Error creating gradient bar image: {e}")
            return None
    
    def _create_smooth_gradient_bar(self, image: Image.Image, gradient):
        """Create smooth gradient bar using CORRECTED position logic"""
        width, height = image.size
        pixels = image.load()
        
        # Get elevation range
        min_elev = gradient.min_elevation
        max_elev = gradient.max_elevation
        elev_range = max_elev - min_elev
        
        for y in range(height):
            # Calculate position (0.0 at top, 1.0 at bottom)
            position = y / (height - 1) if height > 1 else 0
            
            # Convert position to elevation - CORRECTED FORMULA
            # elevation = min_elev + (max_elev - min_elev) * (1 - position)
            elevation = min_elev + (elev_range * (1 - position))
            
            # Get color for this elevation using gradient's color calculation
            color = self._get_color_for_elevation(gradient, elevation, min_elev, max_elev)
            
            # Fill entire row with this color
            for x in range(width):
                pixels[x, y] = color
    
    def _create_posterized_gradient_bar(self, image: Image.Image, gradient):
        """Create posterized gradient bar using CORRECTED position logic"""
        width, height = image.size
        pixels = image.load()
        
        # Get elevation range
        min_elev = gradient.min_elevation
        max_elev = gradient.max_elevation
        elev_range = max_elev - min_elev
        
        # Convert color stops to points with CORRECT position interpretation
        points = []
        for stop in gradient.color_stops:
            # Position 0.0 = top of image (y=0), Position 1.0 = bottom of image (y=height)
            y_pixel = stop.position * height
            
            # Calculate elevation - CORRECTED FORMULA
            # elevation = min_elev + (max_elev - min_elev) * (1 - position)
            elevation = min_elev + (elev_range * (1 - stop.position))
            
            points.append({
                'y_pixel': int(y_pixel),
                'position': stop.position,
                'elevation': elevation,
                'color': (stop.red, stop.green, stop.blue)
            })
        
        # Sort points by position (top to bottom in image)
        sorted_points = sorted(points, key=lambda p: p['position'])
        
        # Draw "above posterized" color at the top if it exists
        if (hasattr(gradient, 'below_gradient_color') and gradient.below_gradient_color and 
            gradient.gradient_type in ['posterized', 'shading_and_posterized']):
            
            # Above posterized color fills from top (y=0) to first point
            if sorted_points:
                first_point = sorted_points[0]  # First point (smallest position)
                top_band_bottom_y = first_point['y_pixel']
                
                # Draw "above posterized" color from top to first point
                if top_band_bottom_y > 0:
                    above_posterized_color = (
                        gradient.below_gradient_color.get('red', 255),
                        gradient.below_gradient_color.get('green', 0), 
                        gradient.below_gradient_color.get('blue', 0)
                    )
                    
                    # Fill the top area with above posterized color
                    for y in range(0, top_band_bottom_y):
                        for x in range(width):
                            if 0 <= y < height:
                                pixels[x, y] = above_posterized_color
        
        # Fill gradient bar using posterized bands
        # Each color fills FROM its position DOWN to the next position
        for i in range(len(sorted_points)):
            current_point = sorted_points[i]
            color = current_point['color']
            
            # Band starts at this point's Y position
            band_top = current_point['y_pixel']
            
            # Band extends downward to the next point's Y position (or bottom if last point)
            if i == len(sorted_points) - 1:
                # Last point: extends to bottom of image
                band_bottom = height
            else:
                # Other points: extend downward to next point's Y position
                next_point = sorted_points[i + 1]
                band_bottom = next_point['y_pixel']
            
            # Fill the band (only if it has height)
            if band_bottom > band_top:
                for y in range(band_top, band_bottom):
                    for x in range(width):
                        if 0 <= y < height:
                            pixels[x, y] = color
    
    def _get_color_for_elevation(self, gradient, elevation: float, min_elev: float, max_elev: float) -> Tuple[int, int, int]:
        """Get RGB color for specific elevation using CORRECTED position calculation"""
        # Convert elevation to position - CORRECTED FORMULA
        # position = 1 - ((elevation - min_elev) / (max_elev - min_elev))
        if max_elev == min_elev:
            position = 0.0
        else:
            position = 1.0 - ((elevation - min_elev) / (max_elev - min_elev))
        
        # Clamp position to 0-1 range
        position = max(0.0, min(1.0, position))
        
        return self._get_color_at_position(gradient, position)
    
    def _get_color_at_position(self, gradient, position: float) -> Tuple[int, int, int]:
        """Get RGB color at specific position in gradient"""
        # Find the two color stops that bracket this position
        for i in range(len(gradient.color_stops) - 1):
            stop1 = gradient.color_stops[i]
            stop2 = gradient.color_stops[i + 1]
            
            if stop1.position <= position <= stop2.position:
                # Interpolate between the two stops
                if stop1.position == stop2.position:
                    # Avoid division by zero
                    return (stop1.red, stop1.green, stop1.blue)
                
                # Calculate interpolation factor
                t = (position - stop1.position) / (stop2.position - stop1.position)
                
                # Interpolate RGB values
                r = int(stop1.red + t * (stop2.red - stop1.red))
                g = int(stop1.green + t * (stop2.green - stop1.green))
                b = int(stop1.blue + t * (stop2.blue - stop1.blue))
                
                return (r, g, b)
        
        # If position is outside range, use nearest color
        if position <= gradient.color_stops[0].position:
            stop = gradient.color_stops[0]
            return (stop.red, stop.green, stop.blue)
        else:
            stop = gradient.color_stops[-1]
            return (stop.red, stop.green, stop.blue)
    
    def _format_coordinate(self, decimal_degrees: float, is_latitude: bool) -> str:
        """Format coordinate as degrees/minutes/seconds"""
        abs_degrees = abs(decimal_degrees)
        degrees = int(abs_degrees)
        minutes_float = (abs_degrees - degrees) * 60
        minutes = int(minutes_float)
        seconds = (minutes_float - minutes) * 60
        
        # Determine direction
        if is_latitude:
            direction = "N" if decimal_degrees >= 0 else "S"
        else:
            direction = "E" if decimal_degrees >= 0 else "W"
        
        return f"{degrees}¬∞{minutes}'{seconds:.1f}\"{direction}"
    
    def _calculate_width_distance(self, west: float, east: float, latitude: float) -> Tuple[float, float]:
        """Calculate distance between west and east at given latitude"""
        # Convert to radians
        lat_rad = math.radians(latitude)
        
        # Calculate distance
        degree_width = east - west
        km_per_degree = (2 * math.pi * self.earth_radius_km) / 360.0
        width_km = degree_width * km_per_degree * math.cos(lat_rad)
        width_mi = width_km / 1.609344
        
        return width_km, width_mi
    
    def _calculate_height_distance(self, north: float, south: float) -> Tuple[float, float]:
        """Calculate distance between north and south"""
        degree_height = north - south
        km_per_degree = (2 * math.pi * self.earth_radius_km) / 360.0
        height_km = degree_height * km_per_degree
        height_mi = height_km / 1.609344
        
        return height_km, height_mi
    
    def _get_gradient_type_name(self, gradient_type: str) -> str:
        """Convert gradient type to display name"""
        type_names = {
            'shaded_relief': 'Shaded relief',
            'gradient': 'Smooth gradient',
            'posterized': 'Posterized',
            'shading_and_gradient': 'Gradient and Shaded relief',
            'shading_and_posterized': 'Posterized and Shaded relief'
        }
        return type_names.get(gradient_type, gradient_type)

def create_key_filename(image_path: str, suffix: str = "_key") -> str:
    """
    Create Key file filename from image path
    
    Args:
        image_path: Path to the image file
        suffix: Suffix to add before extension
        
    Returns:
        str: Path for the Key file
    """
    path = Path(image_path)
    stem = path.stem
    parent = path.parent
    
    return str(parent / f"{stem}{suffix}.pdf")